Object.defineProperty(exports, '__esModule', {
  value: true
});

var wonka = require('wonka');

var core = require('@urql/core');

const retryExchange = ({
  initialDelayMs,
  maxDelayMs,
  randomDelay,
  maxNumberAttempts,
  retryIf,
  retryWith
}) => {
  const MIN_DELAY = initialDelayMs || 1000;
  const MAX_DELAY = maxDelayMs || 15000;
  const MAX_ATTEMPTS = maxNumberAttempts || 2;
  const RANDOM_DELAY = randomDelay !== undefined ? !!randomDelay : true;
  return ({
    forward,
    dispatchDebug
  }) => ops$ => {
    const sharedOps$ = wonka.share(ops$);
    const {
      source: retry$,
      next: nextRetryOperation
    } = wonka.makeSubject();
    const retryWithBackoff$ = wonka.mergeMap(op => {
      const {
        key,
        context
      } = op;
      const retryCount = (context.retryCount || 0) + 1;
      let delayAmount = context.retryDelay || MIN_DELAY;
      const backoffFactor = Math.random() + 1.5; // if randomDelay is enabled and it won't exceed the max delay, apply a random
      // amount to the delay to avoid thundering herd problem

      if (RANDOM_DELAY && delayAmount * backoffFactor < MAX_DELAY) {
        delayAmount *= backoffFactor;
      } // We stop the retries if a teardown event for this operation comes in
      // But if this event comes through regularly we also stop the retries, since it's
      // basically the query retrying itself, no backoff should be added!


      const teardown$ = wonka.filter(op => {
        return (op.kind === 'query' || op.kind === 'teardown') && op.key === key;
      })(sharedOps$);
      process.env.NODE_ENV !== 'production' ? dispatchDebug({
        type: 'retryAttempt',
        message: `The operation has failed and a retry has been triggered (${retryCount} / ${MAX_ATTEMPTS})`,
        operation: op,
        data: {
          retryCount
        },
        "source": "retryExchange"
      }) : undefined; // Add new retryDelay and retryCount to operation

      return (// Stop retry if a teardown comes in
        wonka.takeUntil(teardown$)(wonka.debounce(() => delayAmount)(wonka.fromValue(core.makeOperation(op.kind, op, { ...op.context,
          retryDelay: delayAmount,
          retryCount
        }))))
      );
    })(retry$);
    const result$ = wonka.filter(res => {
      // Only retry if the error passes the conditional retryIf function (if passed)
      // or if the error contains a networkError
      if (!res.error || (retryIf ? !retryIf(res.error, res.operation) : !retryWith && !res.error.networkError)) {
        return true;
      }

      const maxNumberAttemptsExceeded = (res.operation.context.retryCount || 0) >= MAX_ATTEMPTS - 1;

      if (!maxNumberAttemptsExceeded) {
        const operation = retryWith ? retryWith(res.error, res.operation) : res.operation;
        if (!operation) return true; // Send failed responses to be retried by calling next on the retry$ subject
        // Exclude operations that have been retried more than the specified max

        nextRetryOperation(operation);
        return false;
      }

      process.env.NODE_ENV !== 'production' ? dispatchDebug({
        type: 'retryExhausted',
        message: 'Maximum number of retries has been reached. No further retries will be performed.',
        operation: res.operation,
        "source": "retryExchange"
      }) : undefined;
      return true;
    })(wonka.share(forward(wonka.merge([sharedOps$, retryWithBackoff$]))));
    return result$;
  };
};

exports.retryExchange = retryExchange;
//# sourceMappingURL=urql-exchange-retry.js.map
