import { share as r, makeSubject as e, mergeMap as t, filter as o, takeUntil as n, debounce as a, fromValue as s, merge as i } from "wonka";

import { makeOperation as c } from "@urql/core";

const retryExchange = ({initialDelayMs: u, maxDelayMs: y, randomDelay: p, maxNumberAttempts: d, retryIf: m, retryWith: f}) => {
  const h = u || 1e3;
  const l = y || 15e3;
  const x = d || 2;
  const D = void 0 !== p ? !!p : !0;
  return ({forward: u, dispatchDebug: y}) => p => {
    const d = r(p);
    const {source: E, next: g} = e();
    const k = t((r => {
      const {key: e, context: t} = r;
      const i = (t.retryCount || 0) + 1;
      let u = t.retryDelay || h;
      const p = Math.random() + 1.5;
      if (D && u * p < l) {
        u *= p;
      }
      const m = o((r => ("query" === r.kind || "teardown" === r.kind) && r.key === e))(d);
      "production" !== process.env.NODE_ENV && y({
        type: "retryAttempt",
        message: `The operation has failed and a retry has been triggered (${i} / ${x})`,
        operation: r,
        data: {
          retryCount: i
        },
        source: "retryExchange"
      });
      return n(m)(a((() => u))(s(c(r.kind, r, {
        ...r.context,
        retryDelay: u,
        retryCount: i
      }))));
    }))(E);
    return o((r => {
      if (!(r.error && (m ? m(r.error, r.operation) : f || r.error.networkError))) {
        return !0;
      }
      if (!((r.operation.context.retryCount || 0) >= x - 1)) {
        const e = f ? f(r.error, r.operation) : r.operation;
        if (!e) {
          return !0;
        }
        g(e);
        return !1;
      }
      "production" !== process.env.NODE_ENV && y({
        type: "retryExhausted",
        message: "Maximum number of retries has been reached. No further retries will be performed.",
        operation: r.operation,
        source: "retryExchange"
      });
      return !0;
    }))(r(u(i([ d, k ]))));
  };
};

export { retryExchange };
//# sourceMappingURL=urql-exchange-retry.mjs.map
