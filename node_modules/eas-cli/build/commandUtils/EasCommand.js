"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const AnalyticsManager_1 = require("../analytics/AnalyticsManager");
const SessionManager_1 = tslib_1.__importDefault(require("../user/SessionManager"));
const AnalyticsContextField_1 = tslib_1.__importDefault(require("./context/AnalyticsContextField"));
const DynamicProjectConfigContextField_1 = require("./context/DynamicProjectConfigContextField");
const LoggedInContextField_1 = tslib_1.__importDefault(require("./context/LoggedInContextField"));
const MaybeLoggedInContextField_1 = tslib_1.__importDefault(require("./context/MaybeLoggedInContextField"));
const OptionalProjectConfigContextField_1 = require("./context/OptionalProjectConfigContextField");
const ProjectConfigContextField_1 = tslib_1.__importDefault(require("./context/ProjectConfigContextField"));
const ProjectDirContextField_1 = tslib_1.__importDefault(require("./context/ProjectDirContextField"));
const SessionManagementContextField_1 = tslib_1.__importDefault(require("./context/SessionManagementContextField"));
class EasCommand extends core_1.Command {
    /**
     * Execute the context in the contextDefinition to satisfy command prerequisites.
     */
    async getContextAsync(commandClass, { nonInteractive }) {
        const contextDefinition = commandClass.contextDefinition;
        // do these serially so that they don't do things like ask for login twice in parallel
        const contextValuePairs = [];
        for (const [contextKey, contextField] of Object.entries(contextDefinition)) {
            contextValuePairs.push([
                contextKey,
                await contextField.getValueAsync({
                    nonInteractive,
                    sessionManager: this.sessionManager,
                    analytics: this.analytics,
                }),
            ]);
        }
        return Object.fromEntries(contextValuePairs);
    }
    get sessionManager() {
        return (0, nullthrows_1.default)(this.sessionManagerInternal);
    }
    get analytics() {
        return (0, nullthrows_1.default)(this.analyticsInternal);
    }
    // eslint-disable-next-line async-protect/async-suffix
    async run() {
        this.analyticsInternal = await (0, AnalyticsManager_1.createAnalyticsAsync)();
        this.sessionManagerInternal = new SessionManager_1.default(this.analytics);
        // this is needed for logEvent call below as it identifies the user in the analytics system
        // if possible
        await this.sessionManager.getUserAsync();
        this.analytics.logEvent(AnalyticsManager_1.CommandEvent.ACTION, {
            // id is assigned by oclif in constructor based on the filepath:
            // commands/submit === submit, commands/build/list === build:list
            action: `eas ${this.id}`,
        });
        return this.runAsync();
    }
    // eslint-disable-next-line async-protect/async-suffix
    async finally(err) {
        await this.analytics.flushAsync();
        return super.finally(err);
    }
}
exports.default = EasCommand;
EasCommand.ContextOptions = {
    /**
     * Require this command to be run when logged-in. Returns the logged-in actor and a logged-in
     * graphql client in the context.
     */
    LoggedIn: {
        loggedIn: new LoggedInContextField_1.default(),
    },
    /**
     * Do not require this command to be run when logged-in, but if it is get the logged-in actor and a
     * maybe-logged-in graphql client.
     */
    MaybeLoggedIn: {
        maybeLoggedIn: new MaybeLoggedInContextField_1.default(),
    },
    /**
     * Specify this context requirement if the command needs to mutate the user session.
     */
    SessionManagment: {
        sessionManager: new SessionManagementContextField_1.default(),
    },
    /**
     * Require the project to be identified and registered on server if this command is being
     * run within a project directory, null otherwise.
     */
    OptionalProjectConfig: {
        projectConfig: new OptionalProjectConfigContextField_1.OptionalProjectConfigContextField(),
    },
    /**
     * Require this command to be run in a project directory. Return the project directory in the context.
     */
    ProjectDir: {
        projectDir: new ProjectDirContextField_1.default(),
    },
    /**
     * Provides functions to load the project config when dynamic config options are needed (custom Env for example).
     */
    DynamicProjectConfig: {
        // eslint-disable-next-line async-protect/async-suffix
        getDynamicProjectConfigAsync: new DynamicProjectConfigContextField_1.DynamicProjectConfigContextField(),
    },
    /**
     * Require the project to be identified and registered on server. Returns the project config in the context.
     * This also requires the user to be logged in (getProjectIdAsync requires logged in), so also expose that context.
     * Exposing the loggedIn context here helps us guarantee user identification for logging purposes.
     */
    ProjectConfig: {
        loggedIn: new LoggedInContextField_1.default(),
        projectConfig: new ProjectConfigContextField_1.default(),
    },
    /**
     * Analytics manager. Returns the analytics manager in the context for use by the command.
     */
    Analytics: {
        analytics: new AnalyticsContextField_1.default(),
    },
};
/**
 * Context allows for subclasses (commands) to declare their prerequisites in a type-safe manner.
 * These declarative definitions each output a context property that is the result of the prerequisite being
 * satisfied. These allow a unified common interface to be shared amongst commands in order to provide a more
 * consistent CLI experience.
 *
 * For example, let's say a command needs the EAS project ID to make a GraphQL mutation. It should declare that
 * it requires the `ProjectConfig` context, and then call `getContextAsync` to get the project ID.
 */
EasCommand.contextDefinition = {};
