"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForBuildEndAsync = exports.prepareBuildRequestForPlatformAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_progress_1 = tslib_1.__importDefault(require("cli-progress"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const AnalyticsManager_1 = require("../analytics/AnalyticsManager");
const common_1 = require("../analytics/common");
const api_1 = require("../api");
const generated_1 = require("../graphql/generated");
const BuildMutation_1 = require("../graphql/mutations/BuildMutation");
const BuildQuery_1 = require("../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importStar(require("../log"));
const ora_1 = require("../ora");
const platform_1 = require("../platform");
const prompts_1 = require("../prompts");
const uploads_1 = require("../uploads");
const files_1 = require("../utils/files");
const json_1 = require("../utils/json");
const progress_1 = require("../utils/progress");
const promise_1 = require("../utils/promise");
const vcs_1 = require("../vcs");
const graphql_1 = require("./graphql");
const local_1 = require("./local");
const metadata_1 = require("./metadata");
const printBuildInfo_1 = require("./utils/printBuildInfo");
const repository_1 = require("./utils/repository");
function resolveBuildParamsInput(ctx) {
    return {
        resourceClass: ctx.resourceClass,
    };
}
async function prepareBuildRequestForPlatformAsync(builder) {
    const { ctx } = builder;
    const credentialsResult = await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => await builder.ensureCredentialsAsync(ctx), {
        attemptEvent: AnalyticsManager_1.BuildEvent.GATHER_CREDENTIALS_ATTEMPT,
        successEvent: AnalyticsManager_1.BuildEvent.GATHER_CREDENTIALS_SUCCESS,
        failureEvent: AnalyticsManager_1.BuildEvent.GATHER_CREDENTIALS_FAIL,
        properties: ctx.analyticsEventProperties,
    });
    await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => await builder.syncProjectConfigurationAsync(ctx), {
        attemptEvent: AnalyticsManager_1.BuildEvent.CONFIGURE_PROJECT_ATTEMPT,
        successEvent: AnalyticsManager_1.BuildEvent.CONFIGURE_PROJECT_SUCCESS,
        failureEvent: AnalyticsManager_1.BuildEvent.CONFIGURE_PROJECT_FAIL,
        properties: ctx.analyticsEventProperties,
    });
    if (await (0, vcs_1.getVcsClient)().isCommitRequiredAsync()) {
        log_1.default.addNewLineIfNone();
        await (0, repository_1.reviewAndCommitChangesAsync)(`[EAS Build] Run EAS Build for ${platform_1.requestedPlatformDisplayNames[ctx.platform]}`, { nonInteractive: ctx.nonInteractive });
    }
    let projectArchive;
    if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.LOCAL_BUILD_PLUGIN) {
        projectArchive = {
            type: eas_build_job_1.ArchiveSourceType.PATH,
            path: (await (0, repository_1.makeProjectTarballAsync)()).path,
        };
    }
    else if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.INTERNAL) {
        projectArchive = {
            type: eas_build_job_1.ArchiveSourceType.PATH,
            path: process.cwd(),
        };
    }
    else if (!ctx.localBuildOptions.localBuildMode) {
        projectArchive = {
            type: eas_build_job_1.ArchiveSourceType.GCS,
            bucketKey: await uploadProjectAsync(ctx),
        };
    }
    (0, assert_1.default)(projectArchive);
    const metadata = await (0, metadata_1.collectMetadataAsync)(ctx);
    const buildParams = resolveBuildParamsInput(ctx);
    const job = await builder.prepareJobAsync(ctx, {
        projectArchive,
        credentials: credentialsResult === null || credentialsResult === void 0 ? void 0 : credentialsResult.credentials,
    });
    return async () => {
        if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.LOCAL_BUILD_PLUGIN) {
            await (0, local_1.runLocalBuildAsync)(job, metadata, ctx.localBuildOptions);
            return undefined;
        }
        else if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.INTERNAL) {
            await BuildMutation_1.BuildMutation.updateBuildMetadataAsync(ctx.graphqlClient, {
                buildId: (0, nullthrows_1.default)(process.env.EAS_BUILD_ID),
                metadata: (0, graphql_1.transformMetadata)(metadata),
            });
            (0, json_1.printJsonOnlyOutput)({ job, metadata });
            return undefined;
        }
        else if (!ctx.localBuildOptions.localBuildMode) {
            try {
                return await sendBuildRequestAsync(builder, job, metadata, buildParams);
            }
            catch (error) {
                handleBuildRequestError(error, job.platform);
            }
        }
        else {
            throw new Error('Unknown localBuildMode.');
        }
    };
}
exports.prepareBuildRequestForPlatformAsync = prepareBuildRequestForPlatformAsync;
const SERVER_SIDE_DEFINED_ERRORS = [
    'TURTLE_DEPRECATED_JOB_FORMAT',
    'EAS_BUILD_FREE_TIER_DISABLED',
    'EAS_BUILD_FREE_TIER_DISABLED_IOS',
    'EAS_BUILD_FREE_TIER_DISABLED_ANDROID',
    'VALIDATION_ERROR',
];
function handleBuildRequestError(error, platform) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    log_1.default.debug(JSON.stringify(error.graphQLErrors, null, 2));
    if (SERVER_SIDE_DEFINED_ERRORS.includes((_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.errorCode)) {
        log_1.default.error((_e = (_d = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.message);
        throw new Error('Build request failed.');
    }
    else if (((_h = (_g = (_f = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.extensions) === null || _h === void 0 ? void 0 : _h.errorCode) === 'EAS_BUILD_DOWN_FOR_MAINTENANCE') {
        log_1.default.error(`EAS Build is down for maintenance. Try again later. Check ${(0, log_1.link)('https://status.expo.dev/')} for updates.`);
        throw new Error('Build request failed.');
    }
    else if (((_l = (_k = (_j = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _j === void 0 ? void 0 : _j[0]) === null || _k === void 0 ? void 0 : _k.extensions) === null || _l === void 0 ? void 0 : _l.errorCode) === 'EAS_BUILD_TOO_MANY_PENDING_BUILDS') {
        log_1.default.error(`You have already reached the maximum number of pending ${platform_1.requestedPlatformDisplayNames[platform]} builds for your account. Try again later.`);
        throw new Error('Build request failed.');
    }
    else if (error === null || error === void 0 ? void 0 : error.graphQLErrors) {
        log_1.default.error('Build request failed. Make sure you are using the latest eas-cli version. If the problem persists, report the issue.');
    }
    throw error;
}
async function uploadProjectAsync(ctx) {
    let projectTarballPath;
    try {
        return await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => {
            log_1.default.newLine();
            log_1.default.log(`Compressing project files and uploading to EAS Build. ${(0, log_1.learnMore)('https://expo.fyi/eas-build-archive')}`);
            const projectTarball = await (0, repository_1.makeProjectTarballAsync)();
            if (projectTarball.size > 1024 * 1024 * 100) {
                log_1.default.warn(`Your project archive is ${(0, files_1.formatBytes)(projectTarball.size)}. You can reduce its size and the time it takes to upload by excluding files that are unnecessary for the build process in ${chalk_1.default.bold('.easignore')} file. ${(0, log_1.learnMore)('https://expo.fyi/eas-build-archive')}`);
            }
            projectTarballPath = projectTarball.path;
            const bucketKey = await (0, uploads_1.uploadFileAtPathToGCSAsync)(ctx.graphqlClient, generated_1.UploadSessionType.EasBuildGcsProjectSources, projectTarball.path, (0, progress_1.createProgressTracker)({
                total: projectTarball.size,
                message: ratio => `Uploading to EAS Build (${(0, files_1.formatBytes)(projectTarball.size * ratio)} / ${(0, files_1.formatBytes)(projectTarball.size)})`,
                completedMessage: (duration) => `Uploaded to EAS ${chalk_1.default.dim(duration)}`,
            }));
            return bucketKey;
        }, {
            attemptEvent: AnalyticsManager_1.BuildEvent.PROJECT_UPLOAD_ATTEMPT,
            successEvent: AnalyticsManager_1.BuildEvent.PROJECT_UPLOAD_SUCCESS,
            failureEvent: AnalyticsManager_1.BuildEvent.PROJECT_UPLOAD_FAIL,
            properties: ctx.analyticsEventProperties,
        });
    }
    finally {
        if (projectTarballPath) {
            await fs_extra_1.default.remove(projectTarballPath);
        }
    }
}
async function sendBuildRequestAsync(builder, job, metadata, buildParams) {
    const { ctx } = builder;
    return await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => {
        if (log_1.default.isDebug) {
            log_1.default.log(`Starting ${platform_1.requestedPlatformDisplayNames[job.platform]} build`);
        }
        const { build, deprecationInfo } = await builder.sendBuildRequestAsync(ctx.projectId, job, metadata, buildParams);
        (0, printBuildInfo_1.printDeprecationWarnings)(deprecationInfo);
        return build;
    }, {
        attemptEvent: AnalyticsManager_1.BuildEvent.BUILD_REQUEST_ATTEMPT,
        successEvent: AnalyticsManager_1.BuildEvent.BUILD_REQUEST_SUCCESS,
        failureEvent: AnalyticsManager_1.BuildEvent.BUILD_REQUEST_FAIL,
        properties: ctx.analyticsEventProperties,
    });
}
async function waitForBuildEndAsync(graphqlClient, { buildIds, accountName, projectDir, nonInteractive, }, { intervalSec = 10 } = {}) {
    let spinner;
    let originalSpinnerText;
    if (buildIds.length === 1) {
        log_1.default.log('Waiting for build to complete. You can press Ctrl+C to exit.');
        originalSpinnerText = 'Waiting for build to complete.';
        spinner = (0, ora_1.ora)(originalSpinnerText).start();
    }
    else {
        originalSpinnerText = 'Waiting for builds to complete. You can press Ctrl+C to exit.';
        spinner = (0, ora_1.ora)('Waiting for builds to complete. You can press Ctrl+C to exit.').start();
    }
    while (true) {
        const builds = await getBuildsSafelyAsync(graphqlClient, buildIds);
        const { refetch } = builds.length === 1
            ? await handleSingleBuildProgressAsync({ build: builds[0], accountName, projectDir, nonInteractive }, { spinner })
            : await handleMultipleBuildsProgressAsync({ builds }, { spinner, originalSpinnerText });
        if (!refetch) {
            return builds;
        }
        await (0, promise_1.sleepAsync)(intervalSec * 1000);
    }
}
exports.waitForBuildEndAsync = waitForBuildEndAsync;
async function getBuildsSafelyAsync(graphqlClient, buildIds) {
    const promises = buildIds.map(async (buildId) => {
        try {
            return await BuildQuery_1.BuildQuery.byIdAsync(graphqlClient, buildId, { useCache: false });
        }
        catch (err) {
            log_1.default.debug('Failed to fetch the build status', err);
            return null;
        }
    });
    return await Promise.all(promises);
}
let queueProgressBarStarted = false;
const queueProgressBar = new cli_progress_1.default.SingleBar({ format: '|{bar}| {estimatedWaitTime}' }, cli_progress_1.default.Presets.rect);
async function handleSingleBuildProgressAsync({ build, accountName, projectDir, nonInteractive, }, { spinner }) {
    if (build === null) {
        spinner.text = 'Could not fetch the build status. Check your network connection.';
        return { refetch: true };
    }
    if (queueProgressBarStarted && (build === null || build === void 0 ? void 0 : build.status) && build.status !== generated_1.BuildStatus.InQueue) {
        if (build.status === generated_1.BuildStatus.InProgress) {
            queueProgressBar.update(queueProgressBar.getTotal(), {
                estimatedWaitTime: '',
            });
        }
        queueProgressBar.stop();
        log_1.default.newLine();
        queueProgressBarStarted = false;
        spinner.start('Build is about to start');
    }
    switch (build.status) {
        case generated_1.BuildStatus.Finished:
            spinner.succeed('Build finished');
            return { refetch: false };
        case generated_1.BuildStatus.New:
            spinner.text = `Build is waiting to enter the queue. Check your concurrency limit at ${(0, log_1.link)(formatAccountSubscriptionsUrl(accountName))}.`;
            break;
        case generated_1.BuildStatus.InQueue: {
            spinner.text = 'Build queued...';
            const progressBarPayload = typeof build.estimatedWaitTimeLeftSeconds === 'number'
                ? { estimatedWaitTime: formatEstimatedWaitTime(build.estimatedWaitTimeLeftSeconds) }
                : { estimatedWaitTime: '' };
            if (!queueProgressBarStarted &&
                typeof build.initialQueuePosition === 'number' &&
                typeof build.queuePosition === 'number' &&
                typeof build.estimatedWaitTimeLeftSeconds === 'number') {
                spinner.stopAndPersist();
                if (build.priority !== generated_1.BuildPriority.High) {
                    log_1.default.newLine();
                    log_1.default.log('Start builds sooner in the priority queue.');
                    log_1.default.log(`Sign up for EAS Production or Enterprise at ${(0, log_1.link)(formatAccountSubscriptionsUrl(accountName))}`);
                }
                if (build.platform === generated_1.AppPlatform.Ios &&
                    [generated_1.BuildResourceClass.IosIntelLarge, generated_1.BuildResourceClass.IosIntelMedium].includes(build.resourceClass)) {
                    let askToSwitchToM1 = false;
                    if (build.priority === generated_1.BuildPriority.High &&
                        build.estimatedWaitTimeLeftSeconds >= /* 10 minutes */ 10 * 60) {
                        log_1.default.newLine();
                        log_1.default.warn(`Warning: Priority queue wait time for legacy iOS Intel workers is longer than usual (more than 10 minutes).`);
                        log_1.default.warn(`We recommend switching to the new, faster M1 workers for iOS builds.`);
                        log_1.default.warn((0, log_1.learnMore)('https://blog.expo.dev/m1-workers-on-eas-build-dcaa2c1333ad', {
                            learnMoreMessage: 'Learn more on switching to M1 workers.',
                        }));
                        askToSwitchToM1 = true;
                    }
                    else if (build.priority !== generated_1.BuildPriority.High &&
                        build.estimatedWaitTimeLeftSeconds >= /* 120 minutes */ 120 * 60) {
                        log_1.default.newLine();
                        log_1.default.warn(`Warning: Free tier queue wait time for legacy iOS Intel workers is longer than usual.`);
                        log_1.default.warn(`We recommend switching to the new, faster M1 workers for iOS builds.`);
                        log_1.default.warn((0, log_1.learnMore)('https://blog.expo.dev/m1-workers-on-eas-build-dcaa2c1333ad', {
                            learnMoreMessage: 'Learn more on switching to M1 workers.',
                        }));
                        askToSwitchToM1 = true;
                    }
                    if (!nonInteractive && askToSwitchToM1) {
                        const shouldSwitchToM1 = await (0, prompts_1.confirmAsync)({
                            message: `Switch iOS builds to M1 workers (modifies build profiles in eas.json)?`,
                        });
                        if (shouldSwitchToM1) {
                            await updateIosBuildProfilesToUseM1WorkersAsync(projectDir);
                        }
                    }
                }
                log_1.default.newLine();
                log_1.default.log(`Waiting in ${priorityToQueueDisplayName[build.priority]}`);
                queueProgressBar.start(build.initialQueuePosition + 1, build.initialQueuePosition - build.queuePosition + 1, progressBarPayload);
                queueProgressBarStarted = true;
            }
            if (typeof build.queuePosition === 'number') {
                queueProgressBar.update(build.queuePosition, progressBarPayload);
            }
            break;
        }
        case generated_1.BuildStatus.Canceled:
            spinner.fail('Build canceled');
            return { refetch: false };
        case generated_1.BuildStatus.InProgress:
            spinner.text = 'Build in progress...';
            break;
        case generated_1.BuildStatus.Errored:
            spinner.fail('Build failed');
            if (build.error) {
                return { refetch: false };
            }
            else {
                throw new Error('Standalone build failed!');
            }
        default:
            spinner.warn('Unknown status');
            throw new Error(`Unknown build status: ${build.status} - aborting!`);
    }
    return { refetch: true };
}
const priorityToQueueDisplayName = {
    [generated_1.BuildPriority.Normal]: 'Free tier queue',
    [generated_1.BuildPriority.NormalPlus]: 'Free tier queue',
    [generated_1.BuildPriority.High]: 'priority queue',
};
const statusToDisplayName = {
    [generated_1.BuildStatus.New]: 'waiting to enter the queue (concurrency limit reached)',
    [generated_1.BuildStatus.InQueue]: 'in queue',
    [generated_1.BuildStatus.InProgress]: 'in progress',
    [generated_1.BuildStatus.Canceled]: 'canceled',
    [generated_1.BuildStatus.Finished]: 'finished',
    [generated_1.BuildStatus.Errored]: 'failed',
};
const platforms = [generated_1.AppPlatform.Android, generated_1.AppPlatform.Ios];
async function handleMultipleBuildsProgressAsync({ builds: maybeBuilds }, { spinner, originalSpinnerText }) {
    const buildCount = maybeBuilds.length;
    const builds = maybeBuilds.filter(isBuildFragment);
    const allFinished = builds.filter(build => build.status === generated_1.BuildStatus.Finished).length === buildCount;
    const allSettled = builds.filter(build => [generated_1.BuildStatus.Finished, generated_1.BuildStatus.Errored, generated_1.BuildStatus.Canceled].includes(build.status)).length === buildCount;
    if (allSettled) {
        if (allFinished) {
            spinner.succeed(formatSettledBuildsText(builds));
        }
        else {
            spinner.fail(formatSettledBuildsText(builds));
        }
        return { refetch: false };
    }
    else {
        spinner.text = formatPendingBuildsText(originalSpinnerText, builds);
        return { refetch: true };
    }
}
function formatSettledBuildsText(builds) {
    return platforms
        .map(platform => {
        const build = (0, nullthrows_1.default)(builds.find(build => build.platform === platform), `Build for platform ${platform} must be defined in this context`);
        return `${platform_1.appPlatformEmojis[platform]} ${platform_1.appPlatformDisplayNames[platform]} build - status: ${chalk_1.default.bold(statusToDisplayName[build.status])}`;
    })
        .join('\n  ');
}
function formatPendingBuildsText(originalSpinnerText, builds) {
    return [
        originalSpinnerText,
        ...platforms.map(platform => {
            const build = builds.find(build => build.platform === platform);
            const status = build ? statusToDisplayName[build.status] : 'unknown';
            let extraInfo = '';
            if ((build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.InQueue &&
                typeof build.initialQueuePosition === 'number' &&
                typeof build.queuePosition === 'number') {
                const percent = Math.floor(((build.initialQueuePosition - build.queuePosition + 1) /
                    (build.initialQueuePosition + 1)) *
                    100);
                const estimatedWaitTime = typeof build.estimatedWaitTimeLeftSeconds === 'number'
                    ? ` - ${formatEstimatedWaitTime(build.estimatedWaitTimeLeftSeconds)}`
                    : '';
                extraInfo = ` - queue progress: ${chalk_1.default.bold(`${percent}%`)}${estimatedWaitTime}`;
            }
            return `${platform_1.appPlatformEmojis[platform]} ${platform_1.appPlatformDisplayNames[platform]} build - status: ${chalk_1.default.bold(status)}${extraInfo}`;
        }),
    ].join('\n  ');
}
function isBuildFragment(maybeBuild) {
    return maybeBuild !== null;
}
function formatEstimatedWaitTime(estimatedWaitTimeLeftSeconds) {
    if (estimatedWaitTimeLeftSeconds < 5 * 60) {
        return 'starting soon...';
    }
    else {
        const n = Math.floor(estimatedWaitTimeLeftSeconds / (10 * 60)) + 1;
        return `starting in about ${n}0 minutes...`;
    }
}
function formatAccountSubscriptionsUrl(accountName) {
    return new URL(`/accounts/${accountName}/settings/subscriptions`, (0, api_1.getExpoWebsiteBaseUrl)()).toString();
}
async function updateIosBuildProfilesToUseM1WorkersAsync(projectDir) {
    const easJsonAccessor = new eas_json_1.EasJsonAccessor(projectDir);
    await easJsonAccessor.readRawJsonAsync();
    const profileNames = await eas_json_1.EasJsonUtils.getBuildProfileNamesAsync(easJsonAccessor);
    easJsonAccessor.patch(easJsonRawObject => {
        for (const profileName of profileNames) {
            easJsonRawObject.build[profileName].ios = {
                ...easJsonRawObject.build[profileName].ios,
                resourceClass: eas_json_1.ResourceClass.M1_MEDIUM,
            };
        }
        return easJsonRawObject;
    });
    await easJsonAccessor.writeAsync();
    log_1.default.withTick('Updated eas.json. Your next builds will run on M1 workers.');
}
