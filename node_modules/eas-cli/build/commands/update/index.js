"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPublishPlatforms = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const queries_1 = require("../../branch/queries");
const utils_1 = require("../../branch/utils");
const url_1 = require("../../build/utils/url");
const queries_2 = require("../../channel/queries");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const fetch_1 = tslib_1.__importDefault(require("../../fetch"));
const generated_1 = require("../../graphql/generated");
const PublishMutation_1 = require("../../graphql/mutations/PublishMutation");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const publish_1 = require("../../project/publish");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const configure_1 = require("../../update/configure");
const getBranchNameFromChannelNameAsync_1 = require("../../update/getBranchNameFromChannelNameAsync");
const utils_2 = require("../../update/utils");
const code_signing_1 = require("../../utils/code-signing");
const uniqBy_1 = tslib_1.__importDefault(require("../../utils/expodash/uniqBy"));
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
const statuspageService_1 = require("../../utils/statuspageService");
const vcs_1 = require("../../vcs");
exports.defaultPublishPlatforms = ['android', 'ios'];
function getRequestedPlatform(platform) {
    switch (platform) {
        case 'android':
            return platform_1.RequestedPlatform.Android;
        case 'ios':
            return platform_1.RequestedPlatform.Ios;
        case 'web':
            return null;
        case 'all':
            return platform_1.RequestedPlatform.All;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }
}
class UpdatePublish extends EasCommand_1.default {
    async runAsync() {
        var _b, _c;
        const { flags: rawFlags } = await this.parse(UpdatePublish);
        const paginatedQueryOptions = (0, pagination_1.getPaginatedQueryOptions)(rawFlags);
        let { auto: autoFlag, platform: platformFlag, channelName, updateMessage, inputDir, skipBundler, privateKeyPath, json: jsonFlag, nonInteractive, } = this.sanitizeFlags(rawFlags);
        let branchName = this.sanitizeFlags(rawFlags).branchName;
        const { getDynamicProjectConfigAsync, loggedIn: { graphqlClient }, } = await this.getContextAsync(UpdatePublish, {
            nonInteractive,
        });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const { exp: expPossiblyWithoutEasUpdateConfigured, projectId, projectDir, } = await getDynamicProjectConfigAsync({
            isPublicConfig: true,
        });
        const { exp: expPrivate } = await getDynamicProjectConfigAsync({
            isPublicConfig: false,
        });
        await (0, statuspageService_1.maybeWarnAboutEasOutagesAsync)(graphqlClient, [generated_1.StatuspageServiceName.EasUpdate]);
        await (0, configure_1.ensureEASUpdateIsConfiguredAsync)(graphqlClient, {
            exp: expPossiblyWithoutEasUpdateConfigured,
            platform: getRequestedPlatform(platformFlag),
            projectDir,
            projectId,
        });
        const { exp } = await getDynamicProjectConfigAsync({});
        const codeSigningInfo = await (0, code_signing_1.getCodeSigningInfoAsync)(expPrivate, privateKeyPath);
        let realizedPlatforms = [];
        if (channelName && branchName) {
            throw new Error('Cannot specify both --channel and --branch. Specify either --channel, --branch, or --auto');
        }
        if (channelName) {
            branchName = await (0, getBranchNameFromChannelNameAsync_1.getBranchNameFromChannelNameAsync)(graphqlClient, projectId, channelName);
        }
        if (!branchName) {
            if (autoFlag) {
                branchName = await (0, utils_1.getDefaultBranchNameAsync)();
            }
            else if (nonInteractive) {
                throw new Error('Must supply --channel, --branch or --auto when in non-interactive mode');
            }
            else {
                try {
                    const branch = await (0, queries_1.selectBranchOnAppAsync)(graphqlClient, {
                        projectId,
                        promptTitle: `Which branch would you like to publish on?`,
                        displayTextForListItem: updateBranch => ({
                            title: `${updateBranch.name} ${chalk_1.default.grey(`- current update: ${(0, utils_2.formatUpdateMessage)(updateBranch.updates[0])}`)}`,
                        }),
                        paginatedQueryOptions,
                    });
                    branchName = branch.name;
                }
                catch {
                    // unable to select a branch (network error or no branches for project)
                    ({ name: branchName } = await (0, prompts_1.promptAsync)({
                        type: 'text',
                        name: 'name',
                        message: 'No branches found. Provide a branch name:',
                        initial: await (0, utils_1.getDefaultBranchNameAsync)(),
                        validate: value => (value ? true : 'Branch name may not be empty.'),
                    }));
                }
                (0, assert_1.default)(branchName, 'Branch name must be specified.');
            }
        }
        if (!updateMessage && autoFlag) {
            updateMessage = (_b = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _b === void 0 ? void 0 : _b.trim();
        }
        if (!updateMessage) {
            if (nonInteractive) {
                throw new Error('Must supply --message or use --auto when in non-interactive mode');
            }
            const validationMessage = 'publish message may not be empty.';
            if (jsonFlag) {
                throw new Error(validationMessage);
            }
            ({ updateMessage } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'updateMessage',
                message: `Provide an update message.`,
                initial: (_c = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _c === void 0 ? void 0 : _c.trim(),
                validate: (value) => (value ? true : validationMessage),
            }));
        }
        // build bundle and upload assets for a new publish
        if (!skipBundler) {
            const bundleSpinner = (0, ora_1.ora)().start('Exporting...');
            try {
                await (0, publish_1.buildBundlesAsync)({ projectDir, inputDir, exp, platformFlag });
                bundleSpinner.succeed('Exported bundle(s)');
            }
            catch (e) {
                bundleSpinner.fail('Export failed');
                throw e;
            }
        }
        // After possibly bundling, assert that the input directory can be found.
        const distRoot = await (0, publish_1.resolveInputDirectoryAsync)(inputDir, { skipBundler });
        const assetSpinner = (0, ora_1.ora)().start('Uploading...');
        let unsortedUpdateInfoGroups = {};
        let uploadedAssetCount = 0;
        let assetLimitPerUpdateGroup = 0;
        try {
            const collectedAssets = await (0, publish_1.collectAssetsAsync)(distRoot);
            const assets = (0, publish_1.filterExportedPlatformsByFlag)(collectedAssets, platformFlag);
            realizedPlatforms = Object.keys(assets);
            const uploadResults = await (0, publish_1.uploadAssetsAsync)(graphqlClient, assets, projectId, (totalAssets, missingAssets) => {
                assetSpinner.text = `Uploading (${totalAssets - missingAssets}/${totalAssets})`;
            });
            uploadedAssetCount = uploadResults.uniqueUploadedAssetCount;
            assetLimitPerUpdateGroup = uploadResults.assetLimitPerUpdateGroup;
            unsortedUpdateInfoGroups = await (0, publish_1.buildUnsortedUpdateInfoGroupAsync)(assets, exp);
            // NOTE(cedric): we assume that bundles are always uploaded, and always are part of
            // `uploadedAssetCount`, perferably we don't assume. For that, we need to refactor the
            // `uploadAssetsAsync` and be able to determine asset type from the uploaded assets.
            const uploadedBundleCount = uploadResults.launchAssetCount;
            const uploadedNormalAssetCount = Math.max(0, uploadedAssetCount - uploadedBundleCount);
            const reusedNormalAssetCount = uploadResults.uniqueAssetCount - uploadedNormalAssetCount;
            assetSpinner.stop();
            log_1.default.withTick(`Uploaded ${uploadedBundleCount} app ${uploadedBundleCount === 1 ? 'bundle' : 'bundles'}`);
            if (uploadedNormalAssetCount === 0) {
                log_1.default.withTick(`Uploading assets skipped - no new assets found`);
            }
            else {
                let message = `Uploaded ${uploadedNormalAssetCount} ${uploadedNormalAssetCount === 1 ? 'asset' : 'assets'}`;
                if (reusedNormalAssetCount > 0) {
                    message += ` (reused ${reusedNormalAssetCount} ${reusedNormalAssetCount === 1 ? 'asset' : 'assets'})`;
                }
                log_1.default.withTick(message);
            }
            for (const uploadedAssetPath of uploadResults.uniqueUploadedAssetPaths) {
                log_1.default.debug(chalk_1.default.dim(`- ${uploadedAssetPath}`));
            }
        }
        catch (e) {
            assetSpinner.fail('Failed to upload');
            throw e;
        }
        const truncatedMessage = (0, utils_2.truncateString)(updateMessage, 1024);
        if (truncatedMessage !== updateMessage) {
            log_1.default.warn('Update message exceeds the allowed 1024 character limit. Truncating message...');
        }
        const runtimeVersions = await getRuntimeVersionObjectAsync(exp, realizedPlatforms, projectDir);
        const runtimeToPlatformMapping = [];
        for (const runtime of runtimeVersions) {
            const platforms = runtimeVersions
                .filter(({ runtimeVersion }) => runtimeVersion === runtime.runtimeVersion)
                .map(({ platform }) => platform);
            if (!runtimeToPlatformMapping.find(item => item.runtimeVersion === runtime.runtimeVersion)) {
                runtimeToPlatformMapping.push({ runtimeVersion: runtime.runtimeVersion, platforms });
            }
        }
        const { branchId, createdBranch } = await (0, queries_1.ensureBranchExistsAsync)(graphqlClient, {
            appId: projectId,
            branchName,
        });
        if (createdBranch) {
            await (0, queries_2.ensureChannelExistsAsync)(graphqlClient, {
                appId: projectId,
                branchId,
                channelName: branchName,
            });
        }
        log_1.default.withTick(`Channel: ${chalk_1.default.bold(branchName)} pointed at branch: ${chalk_1.default.bold(branchName)}`);
        const vcsClient = (0, vcs_1.getVcsClient)();
        const gitCommitHash = await vcsClient.getCommitHashAsync();
        const isGitWorkingTreeDirty = await vcsClient.hasUncommittedChangesAsync();
        // Sort the updates into different groups based on their platform specific runtime versions
        const updateGroups = runtimeToPlatformMapping.map(({ runtimeVersion, platforms }) => {
            const localUpdateInfoGroup = Object.fromEntries(platforms.map(platform => [
                platform,
                unsortedUpdateInfoGroups[platform],
            ]));
            return {
                branchId,
                updateInfoGroup: localUpdateInfoGroup,
                runtimeVersion,
                message: truncatedMessage,
                gitCommitHash,
                isGitWorkingTreeDirty,
                awaitingCodeSigningInfo: !!codeSigningInfo,
            };
        });
        let newUpdates;
        const publishSpinner = (0, ora_1.ora)('Publishing...').start();
        try {
            newUpdates = await PublishMutation_1.PublishMutation.publishUpdateGroupAsync(graphqlClient, updateGroups);
            if (codeSigningInfo) {
                log_1.default.log('🔒 Signing updates');
                const updatesTemp = [...newUpdates];
                const updateGroupsAndTheirUpdates = updateGroups.map(updateGroup => {
                    const newUpdates = updatesTemp.splice(0, Object.keys(updateGroup.updateInfoGroup).length);
                    return {
                        updateGroup,
                        newUpdates,
                    };
                });
                await Promise.all(updateGroupsAndTheirUpdates.map(async ({ updateGroup, newUpdates }) => {
                    await Promise.all(newUpdates.map(async (newUpdate) => {
                        const response = await (0, fetch_1.default)(newUpdate.manifestPermalink, {
                            method: 'GET',
                            headers: { accept: 'multipart/mixed' },
                        });
                        const manifestBody = (0, nullthrows_1.default)(await (0, code_signing_1.getManifestBodyAsync)(response));
                        (0, code_signing_1.checkManifestBodyAgainstUpdateInfoGroup)(manifestBody, (0, nullthrows_1.default)(updateGroup.updateInfoGroup[newUpdate.platform]));
                        const manifestSignature = (0, code_signing_1.signManifestBody)(manifestBody, codeSigningInfo);
                        await PublishMutation_1.PublishMutation.setCodeSigningInfoAsync(graphqlClient, newUpdate.id, {
                            alg: codeSigningInfo.codeSigningMetadata.alg,
                            keyid: codeSigningInfo.codeSigningMetadata.keyid,
                            sig: manifestSignature,
                        });
                    }));
                }));
            }
            publishSpinner.succeed('Published!');
        }
        catch (e) {
            publishSpinner.fail('Failed to publish updates');
            throw e;
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)((0, utils_2.getUpdateGroupJsonInfo)(newUpdates));
        }
        else {
            if (new Set(newUpdates.map(update => update.group)).size > 1) {
                log_1.default.addNewLineIfNone();
                log_1.default.log('👉 Since multiple runtime versions are defined, multiple update groups have been published.');
            }
            log_1.default.addNewLineIfNone();
            for (const runtime of (0, uniqBy_1.default)(runtimeVersions, version => version.runtimeVersion)) {
                const newUpdatesForRuntimeVersion = newUpdates.filter(update => update.runtimeVersion === runtime.runtimeVersion);
                if (newUpdatesForRuntimeVersion.length === 0) {
                    throw new Error(`Publish response is missing updates with runtime ${runtime.runtimeVersion}.`);
                }
                const platforms = newUpdatesForRuntimeVersion.map(update => update.platform);
                const newAndroidUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'android');
                const newIosUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'ios');
                const updateGroupId = newUpdatesForRuntimeVersion[0].group;
                const projectName = exp.slug;
                const accountName = (await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId)).name;
                const updateGroupUrl = (0, url_1.getUpdateGroupUrl)(accountName, projectName, updateGroupId);
                const updateGroupLink = (0, log_1.link)(updateGroupUrl, { dim: false });
                log_1.default.log((0, formatFields_1.default)([
                    { label: 'Branch', value: branchName },
                    { label: 'Runtime version', value: runtime.runtimeVersion },
                    { label: 'Platform', value: platforms.join(', ') },
                    { label: 'Update group ID', value: updateGroupId },
                    ...(newAndroidUpdate
                        ? [{ label: 'Android update ID', value: newAndroidUpdate.id }]
                        : []),
                    ...(newIosUpdate ? [{ label: 'iOS update ID', value: newIosUpdate.id }] : []),
                    { label: 'Message', value: truncatedMessage },
                    ...(gitCommitHash
                        ? [
                            {
                                label: 'Commit',
                                value: `${gitCommitHash}${isGitWorkingTreeDirty ? '*' : ''}`,
                            },
                        ]
                        : []),
                    { label: 'Website link', value: updateGroupLink },
                ]));
                log_1.default.addNewLineIfNone();
                if ((0, publish_1.isUploadedAssetCountAboveWarningThreshold)(uploadedAssetCount, assetLimitPerUpdateGroup)) {
                    log_1.default.warn(`This update group contains ${uploadedAssetCount} assets and is nearing the server cap of ${assetLimitPerUpdateGroup}.\n` +
                        `${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/optimize-assets/', {
                            learnMoreMessage: 'Consider optimizing your usage of assets',
                            dim: false,
                        })}.`);
                    log_1.default.addNewLineIfNone();
                }
            }
        }
    }
    sanitizeFlags(flags) {
        var _b, _c;
        const nonInteractive = (_b = flags['non-interactive']) !== null && _b !== void 0 ? _b : false;
        const { auto, branch: branchName, channel: channelName, message: updateMessage } = flags;
        if (nonInteractive && !auto && !(updateMessage && (branchName || channelName))) {
            core_1.Errors.error('--branch and --message, or --channel and --message are required when updating in non-interactive mode unless --auto is specified', { exit: 1 });
        }
        if (flags.group || flags.republish) {
            // Pick the first flag set that is defined, in this specific order
            const args = [
                ['--group', flags.group],
                ['--branch', flags.branch],
            ].filter(([_, value]) => value)[0];
            log_1.default.newLine();
            log_1.default.warn('The --group and --republish flags are deprecated, use the republish command instead:');
            log_1.default.warn(`  ${chalk_1.default.bold([`eas update:republish`, ...(args !== null && args !== void 0 ? args : [])].join(' '))}`);
            log_1.default.newLine();
            core_1.Errors.error('--group and --republish flags are deprecated', { exit: 1 });
        }
        return {
            auto,
            branchName,
            channelName,
            updateMessage,
            inputDir: flags['input-dir'],
            skipBundler: flags['skip-bundler'],
            platform: flags.platform,
            privateKeyPath: flags['private-key-path'],
            nonInteractive,
            json: (_c = flags.json) !== null && _c !== void 0 ? _c : false,
        };
    }
}
exports.default = UpdatePublish;
_a = UpdatePublish;
UpdatePublish.description = 'publish an update group';
UpdatePublish.flags = {
    branch: core_1.Flags.string({
        description: 'Branch to publish the update group on',
        required: false,
    }),
    channel: core_1.Flags.string({
        description: 'Channel that the published update should affect',
        required: false,
    }),
    message: core_1.Flags.string({
        description: 'A short message describing the update',
        required: false,
    }),
    republish: core_1.Flags.boolean({
        description: 'Republish an update group (deprecated, see republish command)',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    group: core_1.Flags.string({
        description: 'Update group to republish (deprecated, see republish command)',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    'input-dir': core_1.Flags.string({
        description: 'Location of the bundle',
        default: 'dist',
        required: false,
    }),
    'skip-bundler': core_1.Flags.boolean({
        description: `Skip running Expo CLI to bundle the app before publishing`,
        default: false,
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: [
            // TODO: Add web when it's fully supported
            ...exports.defaultPublishPlatforms,
            'all',
        ],
        default: 'all',
        required: false,
    }),
    auto: core_1.Flags.boolean({
        description: 'Use the current git branch and commit message for the EAS branch and update message',
        default: false,
    }),
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory.`,
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
UpdatePublish.contextDefinition = {
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
/** Get runtime versions grouped by platform. Runtime version is always `null` on web where the platform is always backwards compatible. */
async function getRuntimeVersionObjectAsync(exp, platforms, projectDir) {
    var _b, _c;
    for (const platform of platforms) {
        if (platform === 'web') {
            continue;
        }
        const isPolicy = typeof ((_c = (_b = exp[platform]) === null || _b === void 0 ? void 0 : _b.runtimeVersion) !== null && _c !== void 0 ? _c : exp.runtimeVersion) === 'object';
        if (isPolicy) {
            const isManaged = (await (0, workflow_1.resolveWorkflowAsync)(projectDir, platform)) === eas_build_job_1.Workflow.MANAGED;
            if (!isManaged) {
                throw new Error('Runtime version policies are only supported in the managed workflow. In the bare workflow, runtime version needs to be set manually.');
            }
        }
    }
    return [...new Set(platforms)].map(platform => {
        if (platform === 'web') {
            return { platform: 'web', runtimeVersion: 'UNVERSIONED' };
        }
        return {
            platform,
            runtimeVersion: (0, nullthrows_1.default)(config_plugins_1.Updates.getRuntimeVersion(exp, platform), `Unable to determine runtime version for ${platform_1.requestedPlatformDisplayNames[platform]}. ${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/runtime-versions/')}`),
        };
    });
}
