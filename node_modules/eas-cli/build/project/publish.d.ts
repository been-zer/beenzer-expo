/// <reference types="node" />
import { ExpoConfig, Platform } from '@expo/config';
import Joi from 'joi';
import { ExpoGraphqlClient } from '../commandUtils/context/contextUtils/createGraphqlClient';
import { PartialManifestAsset } from '../graphql/generated';
export type ExpoCLIExportPlatformFlag = Platform | 'all';
type Metadata = {
    version: number;
    bundler: 'metro';
    fileMetadata: {
        [key in Platform]: {
            assets: {
                path: string;
                ext: string;
            }[];
            bundle: string;
        };
    };
};
export type RawAsset = {
    fileExtension?: string;
    contentType: string;
    path: string;
};
type CollectedAssets = {
    [platform in Platform]?: {
        launchAsset: RawAsset;
        assets: RawAsset[];
    };
};
type ManifestExtra = {
    expoClient?: {
        [key: string]: any;
    };
    [key: string]: any;
};
type ManifestFragment = {
    launchAsset: PartialManifestAsset;
    assets: PartialManifestAsset[];
    extra?: ManifestExtra;
};
type UpdateInfoGroup = {
    [key in Platform]: ManifestFragment;
};
export declare const MetadataJoi: Joi.ObjectSchema<any>;
export declare function guessContentTypeFromExtension(ext?: string): string;
export declare function getBase64URLEncoding(buffer: Buffer): string;
/**
 * The storage key is used to store the asset in GCS
 */
export declare function getStorageKey(contentType: string, contentHash: string): string;
/**
 * Convenience function that computes an assets storage key starting from its buffer.
 */
export declare function getStorageKeyForAssetAsync(asset: RawAsset): Promise<string>;
export declare function convertAssetToUpdateInfoGroupFormatAsync(asset: RawAsset): Promise<PartialManifestAsset>;
/**
 * This will be sorted later based on the platform's runtime versions.
 */
export declare function buildUnsortedUpdateInfoGroupAsync(assets: CollectedAssets, exp: ExpoConfig): Promise<UpdateInfoGroup>;
export declare function buildBundlesAsync({ projectDir, inputDir, exp, platformFlag, }: {
    projectDir: string;
    inputDir: string;
    exp: Pick<ExpoConfig, 'sdkVersion'>;
    platformFlag: ExpoCLIExportPlatformFlag;
}): Promise<void>;
export declare function resolveInputDirectoryAsync(inputDir: string, { skipBundler }: {
    skipBundler?: boolean;
}): Promise<string>;
export declare function loadMetadata(distRoot: string): Metadata;
export declare function filterExportedPlatformsByFlag<T extends Partial<Record<Platform, any>>>(record: T, platformFlag: ExpoCLIExportPlatformFlag): T;
/** Given a directory, load the metadata.json and collect the assets for each platform. */
export declare function collectAssetsAsync(dir: string): Promise<CollectedAssets>;
export declare function filterOutAssetsThatAlreadyExistAsync(graphqlClient: ExpoGraphqlClient, uniqueAssetsWithStorageKey: (RawAsset & {
    storageKey: string;
})[]): Promise<(RawAsset & {
    storageKey: string;
})[]>;
type AssetUploadResult = {
    assetCount: number;
    uniqueAssetCount: number;
    uniqueUploadedAssetCount: number;
    assetLimitPerUpdateGroup: number;
};
export declare function uploadAssetsAsync(graphqlClient: ExpoGraphqlClient, assetsForUpdateInfoGroup: CollectedAssets, projectId: string, updateSpinnerText?: (totalAssets: number, missingAssets: number) => void): Promise<AssetUploadResult>;
export declare function isUploadedAssetCountAboveWarningThreshold(uploadedAssetCount: number, assetLimitPerUpdateGroup: number): boolean;
export {};
