"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureChannelExistsAsync = exports.createChannelOnAppAsync = exports.listAndRenderBranchesAndUpdatesOnChannelAsync = exports.listAndRenderChannelsOnAppAsync = exports.selectChannelOnAppAsync = exports.CHANNELS_LIMIT = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const client_1 = require("../graphql/client");
const BranchQuery_1 = require("../graphql/queries/BranchQuery");
const ChannelQuery_1 = require("../graphql/queries/ChannelQuery");
const log_1 = tslib_1.__importDefault(require("../log"));
const formatFields_1 = tslib_1.__importDefault(require("../utils/formatFields"));
const json_1 = require("../utils/json");
const queries_1 = require("../utils/queries");
const utils_1 = require("./utils");
exports.CHANNELS_LIMIT = 25;
async function selectChannelOnAppAsync(graphqlClient, { projectId, selectionPromptTitle, paginatedQueryOptions, }) {
    var _a;
    if (paginatedQueryOptions.nonInteractive) {
        throw new Error('Unable to select a channel in non-interactive mode.');
    }
    const updateChannel = await (0, queries_1.paginatedQueryWithSelectPromptAsync)({
        limit: (_a = paginatedQueryOptions.limit) !== null && _a !== void 0 ? _a : exports.CHANNELS_LIMIT,
        offset: paginatedQueryOptions.offset,
        queryToPerform: (limit, offset) => queryChannelsOnAppAsync(graphqlClient, { appId: projectId, limit, offset }),
        promptOptions: {
            title: selectionPromptTitle,
            makePartialChoiceObject: updateChannel => ({ title: updateChannel.name }),
            getIdentifierForQueryItem: updateChannel => updateChannel.id,
        },
    });
    if (!updateChannel) {
        throw new Error(`Could not find any channels for app "${projectId}"`);
    }
    return updateChannel;
}
exports.selectChannelOnAppAsync = selectChannelOnAppAsync;
async function listAndRenderChannelsOnAppAsync(graphqlClient, { projectId, paginatedQueryOptions, }) {
    var _a, _b;
    if (paginatedQueryOptions.nonInteractive) {
        const channels = await queryChannelsOnAppAsync(graphqlClient, {
            appId: projectId,
            limit: (_a = paginatedQueryOptions.limit) !== null && _a !== void 0 ? _a : exports.CHANNELS_LIMIT,
            offset: paginatedQueryOptions.offset,
        });
        renderPageOfChannels(channels, paginatedQueryOptions);
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: (_b = paginatedQueryOptions.limit) !== null && _b !== void 0 ? _b : exports.CHANNELS_LIMIT,
            offset: paginatedQueryOptions.offset,
            queryToPerform: (limit, offset) => queryChannelsOnAppAsync(graphqlClient, { limit, offset, appId: projectId }),
            promptOptions: {
                title: 'Load more channels?',
                renderListItems: channels => renderPageOfChannels(channels, paginatedQueryOptions),
            },
        });
    }
}
exports.listAndRenderChannelsOnAppAsync = listAndRenderChannelsOnAppAsync;
async function listAndRenderBranchesAndUpdatesOnChannelAsync(graphqlClient, { projectId: appId, channelName, paginatedQueryOptions, }) {
    var _a, _b;
    const channel = await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, { appId, channelName });
    renderChannelHeaderContent({ channelName: channel.name, channelId: channel.id });
    if (paginatedQueryOptions.nonInteractive) {
        const branches = await queryBranchesAndUpdateGroupsOnChannelAsync(graphqlClient, {
            appId,
            channelName,
            offset: paginatedQueryOptions.offset,
            limit: (_a = paginatedQueryOptions.limit) !== null && _a !== void 0 ? _a : exports.CHANNELS_LIMIT,
        });
        renderPageOfBranchesOnChannel(channel, branches, paginatedQueryOptions);
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: (_b = paginatedQueryOptions.limit) !== null && _b !== void 0 ? _b : exports.CHANNELS_LIMIT,
            offset: paginatedQueryOptions.offset,
            queryToPerform: (limit, offset) => queryBranchesAndUpdateGroupsOnChannelAsync(graphqlClient, {
                channelName,
                appId,
                offset,
                limit,
            }),
            promptOptions: {
                title: 'Load more channels?',
                renderListItems: branches => renderPageOfBranchesOnChannel(channel, branches, paginatedQueryOptions),
            },
        });
    }
}
exports.listAndRenderBranchesAndUpdatesOnChannelAsync = listAndRenderBranchesAndUpdatesOnChannelAsync;
async function queryChannelsOnAppAsync(graphqlClient, { appId, offset, limit }) {
    return await ChannelQuery_1.ChannelQuery.viewUpdateChannelsOnAppAsync(graphqlClient, {
        appId,
        offset,
        limit,
    });
}
async function queryBranchesAndUpdateGroupsOnChannelAsync(graphqlClient, args) {
    return await BranchQuery_1.BranchQuery.listBranchesOnChannelAsync(graphqlClient, args);
}
function renderPageOfChannels(currentPage, { json }) {
    if (json) {
        (0, json_1.printJsonOnlyOutput)({ currentPage });
    }
    else {
        for (const channel of currentPage) {
            renderChannelHeaderContent({ channelName: channel.name, channelId: channel.id });
            log_1.default.addNewLineIfNone();
            (0, utils_1.logChannelDetails)(channel);
            if (currentPage.indexOf(channel) < currentPage.length - 1) {
                log_1.default.log(`\n${chalk_1.default.dim('———')}\n`);
            }
        }
    }
}
function renderPageOfBranchesOnChannel(channel, currentPage, { json }) {
    const channelWithNewBranches = { ...channel, updateBranches: currentPage };
    if (json) {
        (0, json_1.printJsonOnlyOutput)({ currentPage: channelWithNewBranches });
    }
    else {
        // The channel details contain both the branch and latest update group
        log_1.default.addNewLineIfNone();
        (0, utils_1.logChannelDetails)(channelWithNewBranches);
    }
}
function renderChannelHeaderContent({ channelName, channelId, }) {
    log_1.default.addNewLineIfNone();
    log_1.default.log(chalk_1.default.bold('Channel:'));
    log_1.default.log((0, formatFields_1.default)([
        { label: 'Name', value: channelName },
        { label: 'ID', value: channelId },
    ]));
    log_1.default.addNewLineIfNone();
    log_1.default.log((0, chalk_1.default) `{bold Branches pointed at this channel and their most recent update group:}`);
}
async function createChannelOnAppAsync(graphqlClient, { appId, branchId, channelName, }) {
    // Point the new channel at a branch with its same name.
    const branchMapping = JSON.stringify({
        data: [{ branchId, branchMappingLogic: 'true' }],
        version: 0,
    });
    return await (0, client_1.withErrorHandlingAsync)(graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation CreateUpdateChannelOnApp($appId: ID!, $name: String!, $branchMapping: String!) {
            updateChannel {
              createUpdateChannelForApp(appId: $appId, name: $name, branchMapping: $branchMapping) {
                id
                name
                branchMapping
              }
            }
          }
        `, {
        appId,
        name: channelName,
        branchMapping,
    })
        .toPromise());
}
exports.createChannelOnAppAsync = createChannelOnAppAsync;
async function ensureChannelExistsAsync(graphqlClient, { appId, branchId, channelName }) {
    var _a;
    try {
        await createChannelOnAppAsync(graphqlClient, {
            appId,
            channelName,
            branchId,
        });
    }
    catch (e) {
        const isIgnorableError = ((_a = e.graphQLErrors) === null || _a === void 0 ? void 0 : _a.length) === 1 &&
            e.graphQLErrors[0].extensions.errorCode === 'CHANNEL_ALREADY_EXISTS';
        if (!isIgnorableError) {
            throw e;
        }
    }
}
exports.ensureChannelExistsAsync = ensureChannelExistsAsync;
